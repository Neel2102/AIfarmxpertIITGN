Overall architecture

- High-level: A FastAPI backend orchestrates a suite of domain “agents” (crop planning, operations, supply chain, analytics, support) via an intent-driven workflow engine, with Redis-backed sessions and SQLAlchemy models. A React frontend calls the backend. Configuration and model/LLM services are abstracted behind services/.
- Key directories:
  - Backend HTTP API: interfaces/api/ provides the FastAPI app, CORS, logging middleware, and routes for orchestrator, agents, farms, auth, health.
  - Orchestration core: core/orchestrator/ has FarmOrchestrator, IntentEngine, WorkflowEngine, SessionManager, ResponseSynthesizer.
  - Agent abstraction: core/base_agent/ defines BaseAgent, AgentInterface, AgentRegistry and an enhanced base with status/context models.
  - Agents: agents/ grouped by domain (crop planning, farm operations, supply chain, analytics, support).
  - Config: config/ central settings via Pydantic, DB/Redis factories, and YAML agent workflows.
  - Models/DB: models/ holds SQLAlchemy base and domain/user models.
  - Services: services/ includes LLM, auth/JWT, email, agent config, and utility tools.
  - Frontend: frontend/ is a CRA React app, proxied to the backend.
  - Start scripts: start.py boots the API; start-frontend.py boots the React dev server.
  - Migrations: alembic/ setup and initial migration.
  - Tests: tests/ unit and integration coverage for API and orchestrator.


How components interact

- Request hits FastAPI route → validates request → invokes orchestrator → intent classification → workflow DAG creation → resolves agent order/dependencies → agents execute in sequence/parallel where possible → outputs synthesized and returned. Sessions are created/retrieved in Redis to persist context across turns.


Key design patterns and principles

- Factory/Registry: AgentRegistry registers symbolic agent names and instantiates them via a factory, decoupling orchestrator from agent classes.
- Strategy/Plug-in: Agents conform to AgentInterface and BaseAgent and can be swapped without changing orchestrator code.
- DAG workflow: WorkflowEngine models tasks with dependencies and executes them respecting a dependency graph.
- Configuration-as-data: YAML-driven default plans and workflow templates under config/agent_configs/.
- 12-factor-ish config: Pydantic Settings loads .env and exposes a singleton settings object.
- Event/logging focus: structlog style logger via core.utils.logger.get_logger (referenced), middleware for request logging.
- Layered architecture: API → Orchestration → Agents/Services → Persistence.


Data flow and state management

- Inbound data: HTTP JSON requests from the frontend hit /api/orchestrator/process with query and optional context.
- Session state: SessionManager (Redis-backed) creates/updates sessions with user context, conversation history, preferences, farm data, and active workflows; routes expose session CRUD-like endpoints.
- Workflow state: WorkflowEngine holds active workflows and task statuses (pending/running/completed/failed), timestamps, outputs, and errors.
- Agent data: Agents receive inputs (including session context). Some services call LLMs (GeminiService) or use tools (soil/weather helpers) and return structured outputs: insights, warnings, recommendations.
- Persistence: SQLAlchemy models for farms, fields, crops, tasks, weather data, users, sessions; DB connection via models.database or config.database.


Core functions/algorithms

- FarmOrchestrator.orchestrate: Main pipeline to classify intent, create workflow, execute agents, synthesize response.
- WorkflowEngine: Builds templates, computes dependencies, schedules and executes tasks, updates statuses, and synthesizes combined outputs.
- IntentEngine: Classifies user intent from query (used by orchestrator; implementation wired in orchestrator).
- AgentRegistry: Registers agents and provides create_agent(name) factory.
- AuthService: JWT token creation/verification, password hashing/checking, session/token lifecycle; email for password reset.


External libraries/frameworks

- Python backend (requirements.txt):
  - FastAPI, Uvicorn, Pydantic, pydantic-settings, python-dotenv
  - httpx, structlog, orjson
  - Redis, SQLAlchemy, psycopg2-binary, Alembic
  - PyYAML, google-generativeai, aiohttp, asyncio
  - python-multipart, PyJWT, email-validator
- Frontend (frontend/package.json): React 18, react-router, react-query, axios, styled-components, recharts, testing-library; CRA (react-scripts).


Testing and debugging

- Unit/integration tests: tests/ uses fastapi.testclient for API assertions and an orchestrator flow test.
- Debugging/observability:
  - Request logging middleware enabled in FastAPI app.
  - Structlog-based loggers across orchestrator/engine/services.
  - Health endpoints at /api/health/live and /api/health/ready.
  - Reasoning/workflow endpoints to inspect task status and reasoning trees.


Code style and conventions

- Typing: Modern Python typing with future annotations, Protocol, dataclasses, Enums in enhanced agents.
- Structure: Clear layering and per-domain grouping; __init__.py files mark packages.
- Config: Singleton settings and get_settings() accessor. Environment via .env.
- API: Pydantic schemas under interfaces/api/schemas.
- Formatting/linting: CRA includes ESLint base for frontend; backend follows typed, structured conventions.


Dependencies and versioning

- Python dependencies: pinned in requirements.txt.
- Node dependencies: managed by npm with package-lock.json.
- External services:
  - Gemini API via google-generativeai.
  - Redis for sessions.
  - Database via DATABASE_URL (SQLite default, Postgres example in .env template).
  - SMTP placeholders in EmailService (configure actual credentials in production).
- Versioning: assumed Git; Alembic manages DB schema versions.


Build and deployment process

- Local run
  - Backend: python start.py creates .env template if missing, installs Python deps, and runs uvicorn at farmxpert.interfaces.api.main:app (with --reload in dev).
  - Frontend: python start-frontend.py runs npm install then npm start with CRA dev server (proxy to http://localhost:8000).
- Containers: docker-compose.yml present for containerized dev/prod (configure services accordingly).
- CI/CD: not included; recommended steps are install deps, run tests, build images, and deploy.


Security considerations

- Auth: JWT-based access/refresh tokens with HS256; token creation/verification in AuthService.
- Password storage: PBKDF2 with per-user salt and 100k iterations.
- Config secrets: secret_key and API keys via environment and Pydantic settings; startup warns if Gemini key missing.
- CORS: Restricted to localhost dev origins; credentials enabled.
- Input validation: Pydantic models for API payloads; explicit 400s for invalid input.
- Serialization: orjson for safe/fast JSON.
- Sessions: Redis-backed; secure session endpoints and sanitize stored data in production.
- LLM usage: Timeout and error handling in GeminiService; sanitize prompts/outputs and guardrails recommended for prod.
- Email: SMTP placeholders; use TLS and secret management for credentials in production.


Summary

- Architecture: FastAPI app fronts an intent- and DAG-driven multi-agent core. Agents are pluggable via a registry/factory and orchestrated by workflows with Redis-backed session state.
- Data flow: HTTP → orchestrator → intent → workflow → agents → synthesis → HTTP response; state in Redis and DB.
- Key components: FarmOrchestrator, WorkflowEngine, AgentRegistry, GeminiService, FastAPI routes.
- Stacks: FastAPI, SQLAlchemy, Redis, Gemini API; React frontend via CRA.
- Ops: Start scripts for backend/frontend; tests for health/orchestrator; Alembic for migrations; security via JWT and hashed passwords.


